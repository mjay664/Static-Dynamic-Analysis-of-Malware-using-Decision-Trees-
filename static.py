import os
import re
import pickle
from csv import writer


valid_section_names = ['text', 'data', 'idata', 'rdata', 'reloc', 'rsrc', 'bss', 'exc', 'crt', 'epcl_ini', 'epcl_con', 'boxld01','epcl_set', 'epcl_tes','tls', 'code', 'wixburn', 'epcl_tex']


def todecimal(string):
    if '0x' in string:
        return int(string, 0)
    else:
        return float(string)


def imagefileheaderfeatures(s_list):
    ind = 0
    no_sections = 0
    no_symbols = 0
    size_optional_header = 0
    characterstics = 0
    try:
        ind = s_list.index('NumberOfSections:')
        no_sections = todecimal(s_list[ind+1])
        ind = s_list.index('NumberOfSymbols:')
        no_symbols = todecimal(s_list[ind+1])
        ind = s_list.index('SizeOfOptionalHeader:')
        size_optional_header = todecimal(s_list[ind+1])
        ind = s_list.index('Characteristics:')
        characterstics = todecimal(s_list[ind+1]) 

    except:
        if ind == 0:
            return 0, [0, 0, 0, 0]
    
    return ind, [no_sections, no_symbols, size_optional_header, characterstics]


def imageoptionalheaderfeatures(s_list):

    try:
        code_size = todecimal(s_list[s_list.index('SizeOfCode:')+1])
        size_initialized_data = todecimal(s_list[s_list.index('SizeOfInitializedData:')+1])
        size_image = todecimal(s_list[s_list.index('SizeOfImage:')+1])
        size_header = todecimal(s_list[s_list.index('SizeOfHeaders:')+1])
        size_stack_res = todecimal(s_list[s_list.index('SizeOfStackReserve:')+1])
        size_stack_com = todecimal(s_list[s_list.index('SizeOfStackCommit:')+1])
        size_heap_res = todecimal(s_list[s_list.index('SizeOfHeapReserve:')+1])
        size_heap_com = todecimal(s_list[s_list.index('SizeOfHeapCommit:')+1])
        loader_flags = todecimal(s_list[s_list.index('LoaderFlags:')+1])
        ind = s_list.index('NumberOfRvaAndSizes:')
        no_rvo_sizes = todecimal(s_list[ind+1])

        return ind, [code_size, size_initialized_data, size_image, size_header, size_stack_res, size_stack_com, size_heap_res, size_heap_com, loader_flags, no_rvo_sizes]
    except:
        return 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]


def pesectionfeatures(s_list, no_sections=1):
    try:
        l = []
        ent = []
        isvalidname = 1
        packer = 0
        for i in range(no_sections):
            name = s_list[s_list.index('Name:')+1]
            if isvalidname != 0:
                if '0x' in name or (name[1:].lower() not in valid_section_names and name.lower() not in valid_section_names):
                    isvalidname = 0
            
            l.append(todecimal(s_list[s_list.index('Misc_VirtualSize:')+1]))
            l.append(todecimal(s_list[s_list.index('SizeOfRawData:')+1]))
            l.append(todecimal(s_list[s_list.index('Characteristics:')+1]))
        
            ind = s_list.index('Entropy:')

            if packer != 1 and 'IMAGE_SCN_MEM_EXECUTE' in s_list[s_list.index('Flags:'): ind] and 'IMAGE_SCN_MEM_WRITE' in s_list[s_list.index('Flags:'): ind]:
                packer = 1

            ent.append(todecimal(s_list[ind+1]))

            s_list = s_list[ind+1:]

        l.append(isvalidname)
        l.append(packer)

        return ind, l, ent

    except:
        return 0, []


def directoryfeatures(s_list):
    try:
        l = []
        ind = s_list.index('----------Directories----------')
        s_list = s_list[ind:]
        for i in range(16):
            try:
                ind = s_list.index('Size:')
            except:
                break
            l.append(todecimal(s_list[ind+1]))
            s_list = s_list[ind+1:]
        return ind, l

    except:
        return 0, []


def importsymbolscount(s_list):
    try:
        count = 0
        while('[IMAGE_IMPORT_DESCRIPTOR]' in s_list):
            count += 1
            s_list = s_list[s_list.index('[IMAGE_IMPORT_DESCRIPTOR]')+1:]
        return count
    except:
        return 0


def extractfeatures(dir):

    feature_table = []
    file_names = []

    dirs = os.listdir(dir)
    
    for i in dirs:
        feature = []
        file_names.append(i)
        count = 0
        try:
            f = open(os.path.join(dir + '\\'+i, 'Structure_Info.txt'), 'r', encoding='latin1')
            string = re.sub(r'\s+', ' ', f.read()).replace(',', '').split(' ')
            
            x , l = imagefileheaderfeatures(string)
            feature += l

            sections = l[0]

            string = string[x:]
            x, l = imageoptionalheaderfeatures(string)
            feature += l

            string = string[x:]
            x, l, ent = pesectionfeatures(string, sections)
            feature += l[-2:]

            if sections >= 3:
                feature += l[:9]
                feature += ent[:3]
            else:
                l.pop()
                l.pop()
                feature += l
                for i in range(3 - sections):
                    feature += [0] + [0] + [0]
                feature += ent
                for i in range(3 - sections):
                    feature += [0.0]

            string = string[x:]
            x, l = directoryfeatures(string)
        
            feature += l
            if len(l) != 16:
                for i in range(16-len(l)):
                    feature += [0]
            count += len(l)
            string = string[x:]
            c = importsymbolscount(string)
            feature += [c]

            feature_table.append(feature)
        except:
            tmp = []
            for i in range(45):
                tmp.append(0)
            feature_table.append(tmp) 

    return feature_table, file_names


if __name__ == "__main__":
    path = input('Enter the path: ')
    features, files = extractfeatures(path)

    model = pickle.load(open('dt_model_static', 'rb'))

    predictions = model.predict(features)

    final_list = []
    for i in range(len(predictions)):
        if predictions[i]:
            final_list.append([files[i], 'M'])
        else:
            final_list.append([files[i], 'B'])

    with open("static.csv", "w", newline='') as f:
        writer = writer(f)
        writer.writerow(['FILE_HASH', 'Predicted Label'])
        writer.writerows(final_list)